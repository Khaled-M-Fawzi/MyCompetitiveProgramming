********************* Operations *******************************
splice_after() : transfers the elements from list fl into a list fl1 at position and this leads to the altering 
the sizes of both the list
fl.splice_after(iterator, fl1); // transfer all elements of fl1 to fl , size of fl will increase by size of fl1 , 
size of fl1 will be zero 
fl.splice_after(iterator, fl1, iterator pos1);  // only one element that transferred
fl.splice_after(iterator, fl1, iterator first, iterator last);  
Assume that the number of elements that transferred is k , the size of fl become fl.size+k and the size of fl1 become fl1-k
Complexity : linear in the number of elements transferred

fl.remove(val) : Removes from the list all the elements that compare equal to val
Complexity : Linear in container size

fl.remove_if(function of conditon) : Removes from the list all the elements for which Predicate pred returns true
// a predicate implemented as a function:
bool single_digit (const int& value) { return (value<10); }

// a predicate implemented as a class:
struct is_odd {
  bool operator() (const int& value) { return (value%2)==1; }
};
int main()
{
     forward_list<int>l={34,5,87,50,2,79};
     fl.remove_if (single_digit);        // 5 2
     fl.remove_if (is_odd()); // 87 79
}
Complexity : Linear in list size


fl.unique()  OR unique(pred) // removes all the duplicate elements present consecutively from the list 

bool pred( float x,float y)  
{  
    return(int(x)==int(y));  
}  
forward_list<int>fl={2,2.5,2.3,4,4,4,3,3,4,3}
fl.unique()   // fl becomes 2 , 2.5 , 2.3 , 4, 3 , 4 , 3
fl.unique(pred)  // fl becomes 2  , 4, 3 , 4 , 3
Complexity : Linear in container size 

fl.merge() // merges two sorted list in an increasing order.It merges y list into 
the given list container and this removes all the elements from y
forward_list1.merge(list2);  
forward_list1.merge(list2,compare);  

bool compare(int first, int second)  
{    
    return first<second;  
}  
forward_list<int> forward_li={1,2,3,4};  
forward_list<int> forward_li1={5,6,7,8};  
fl.merge(fl1);  OR li.merge(fl1,compare);
Complexity :  linear in the sum of both container sizes 

fl.sort() OR fl.sort(compare)// arranges the elements of a given list in an increasing order
Complexity : NlogN where N is the container size

fl.reverse() // Reverses the order of the elements in the list container
Complexity : Linear in list size
