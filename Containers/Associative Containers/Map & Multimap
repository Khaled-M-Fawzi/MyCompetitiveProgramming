Maps store elements formed by a combination of a key value and a mapped value, following a specific order
#include <map>
map<int,object_type>object_name;
********************* Iterators *****************************
m.begin()    || O(1) || Returns an iterator pointing to the first element 
m.end()      || O(1) || Returns an iterator pointing to the last element 
m.rbegin()   || O(1) || Returns a reverse iterator pointing to the last element 
m.rend()     || O(1) || Returns a reverse iterator pointing to the first element 
m.cbegin()   || O(1) || Returns a const_iterator pointing to the first element 
m.cend()     || O(1) || Returns a const_iterator pointing to the last element 
m.crbegin()  || O(1) || Returns a const_reverse_iterator pointing to the last element 
m.crend()    || O(1) || Returns a const_reverse_iterator pointing to the first element 
********************* Capacity ********************************
m.size()     || O(1) || Returns the number of elements 
m.max_size() || O(1) || Returns the maximum number of elements that the container can hold
m.empty()    || O(1) || Returns whether the container is empty 
********************* Element Access ************************** 
m.at(pos)    || O(log n) || Returns a reference to the element at position pos (O-Indexed)
operator[pos]|| O(log n) || Returns a reference to the element at position pos (O-Indexed)
********************* Modifiers *******************************
m.insert({key,val}) O(log n)   OR 
m.insert(iterator,{key,val}) O(log n) (faster) //iterator = m.begin()   OR 
m1.insert(m2 first iterator,m2 last iterator) Complexity : number of elements inserted * log n

m.erase(iterator) O(log n) OR m.erase(key) O(log n) OR 
m.erase(first iterator , last iterator) Complexity : number of elements erased * log n


m.emplace({key,val}) || Insert a new element O(log n)   (faster)
m.emplace_hint(iterator,{key,val}) || Insert a new element with a pointer hint O(log n) (faster than v.emplace)
 
m1.swap(m2)         || O(1) || Sawp two container
swap(m[0],m[2])     || O(1) || Sawp two vals
m.clear()  || Linear in size || Removes all elements , leaving the vector with a size of 0
********************* Member functions *******************************
m1.operator=(m2) OR m1=m2|| Linear in size || Assigns new contents , replacing its current contents, and modifying its size   

********************* Operations *******************************
int cnt = m.count(k);
Searches the container for element with a key equivalent to k , return 1 (if the element is found) or zero (otherwise)
if the element not found , the key k wouldn't add at the container

    map<int,int>m;
    m[2] = 3;
    cout<<m.count(2)<<' '<<m.count(4)<<endl; // 1  0
    for(auto x:m)
        cout<<x.first<<' '<<x.second<<endl; //  2  3
        
        
    map<int,int>m;
    m[2] = 3;
    cout<<m[2]<<' '<<m[4]<<endl; // 3  0
    for(auto x:m)
        cout<<x.first<<' '<<x.second<<endl; //  2  3
                                                4  0
        
but not exist at multimap container
Complexity : Logarithmic in size


auto it = m.find(k)
Searches the container for an element with a key equivalent to k and returns an iterator to it if found
otherwise it returns an iterator to map::end

int main ()
{
     map<char,int> mymap;
     map<char,int>::iterator it;

     mymap['a']=50;
     mymap['b']=100;
     mymap['c']=150;
     mymap['d']=200;

     it = mymap.find('b');
     if (it != mymap.end())
     mymap.erase (it);              // erase b

     cout << "a => " << mymap.find('a')->second << '\n';  // 50
     cout << "c => " << mymap.find('c')->second << '\n';  // 150 
     cout << "d => " << mymap.find('d')->second << '\n';  // 200

  return 0;
}
Complexity : Logarithmic in size


 
auto it = st.lower_bound(val)
Returns an iterator pointing to the first element in the container whose key is equal or greater than val
if no such element , it's return iterator  it's key  is size of map and it's second is size-1 of map

    map<char,int> mymap;
    map<char,int>::iterator it;

    mymap['a']=20;
    mymap['b']=40;
    mymap['c']=60;
    it=mymap.lower_bound ('b');  // it points to b 
    
Complexity : Logarithmic in size


auto it = st.upper_bound(val)
Returns an iterator pointing to the first element in the container whose key is  greater than val
if no such element , it's return iterator it's key  is size of map and it's second is size-1 of map

    map<char,int> mymap;
    map<char,int>::iterator it;

    mymap['a']=20;
    mymap['b']=40;
    mymap['c']=60;

    it=mymap.upper_bound ('b');  // it points to c
     
Complexity : Logarithmic in size


                              Equal_range

 int main ()
{
  std::map<char,int> mymap;

  mymap['a']=10;
  mymap['b']=20;
  mymap['c']=30;

  std::pair<std::map<char,int>::iterator,std::map<char,int>::iterator> ret;
  ret = mymap.equal_range('b');

  std::cout << "lower bound points to: ";
  std::cout << ret.first->first << " => " << ret.first->second << '\n';   // lower bound points to: 'b' => 20

  std::cout << "upper bound points to: ";
  std::cout << ret.second->first << " => " << ret.second->second << '\n';  upper bound points to: 'c' => 30

  return 0;
}
Complexity : Logarithmic in size

********************multimap******************
Multimaps store elements formed by a combination of a key value and a mapped value, following a specific order
multimap is a map that allows duplicated keys but not sorted
multimap has properties of map except (at,[]) because Random access is not supported 
