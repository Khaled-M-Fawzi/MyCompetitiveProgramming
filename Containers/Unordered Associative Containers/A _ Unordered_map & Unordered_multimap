unorderedmaps store elements formed by a combination of a key value and a mapped value
#include <unordered_map>
unordered_map<int,object_type>object_name;

********************* Iterators *****************************
m.begin()    || O(1) || Returns an iterator pointing to the first element 
m.end()      || O(1) || Returns an iterator pointing to the last element 
m.cbegin()   || O(1) || Returns a const_iterator pointing to the first element 
m.cend()     || O(1) || Returns a const_iterator pointing to the last element 

********************* Capacity ********************************
m.size()     || O(1) || Returns the number of elements 
m.max_size() || O(1) || Returns the maximum number of elements that the container can hold
m.empty()    || O(1) || Returns whether the container is empty 

********************* Element Access ************************** 
m.at(pos)    || O(1) ~ O(n) || Returns a reference to the element at position pos (O-Indexed)
operator[pos]|| O(1) ~ O(n) || Returns a reference to the element at position pos (O-Indexed)

********************* Modifiers *******************************
m.insert({key,val})   OR 
m.insert(iterator,{key,val})  (faster) //iterator = m.begin()   OR 
m1.insert(m2 first iterator,m2 last iterator) 
Single element insertions:
Average case: constant.
Worst case: linear in container size

Multiple elements insertion:
Average case: linear in the number of elements inserted.
Worst case: N * size: number of elements inserted * the container size

m.erase(iterator) OR m.erase(key)  OR 
m.erase(first iterator , last iterator)
Average case: Linear in the number of elements removed 
Worst case: Linear in the container size

m.emplace({key,val}) ||  Average case: constant , Worst case: linear in container size 
m.emplace_hint(iterator,{key,val}) || Average case: constant , Worst case: linear in container size ) (faster than m.emplace)
 
m1.swap(m2)         || O(1) || Sawp two container
swap(m[0],m[2])     || O(1) || Sawp two values
m.clear()  || Linear in size || Removes all elements , leaving the container with a size of 0

********************* Member functions *******************************
m1.operator=(m2) OR m1=m2|| Linear in size || Assigns new contents , replacing its current contents, and modifying its size   

********************* Buckets *******************************
m.bucket_count() // Returns the number of buckets in the container // O(1)
m.max_bucket_count() // Returns the maximum number of buckets that container can have// O(1)

m.bucket_size(n) // Returns the number of elements in bucket n // O(bucket size)
m.bucket(k) // Returns the bucket number where the element with value k is located // O(1)
Assume that the number of buckets in any container is n , the first bucket = 0 , the second = 1 ,...., the last bucket = n-1

st.rehash(n) // Sets the number of buckets in the container to n or more & n should be greater than bucket.count() to avoid drawbackets
Average case: linear in container size.
Worst case: quadratic in container size.


********************* Operations *******************************
int cnt = m.count(val);
Searches the container for elements with a key equivalent to val and returns the number of matches
Because all elements in a unordered_map container are unique, the function return 1 (if the element is found) or zero(otherwise)
but not at unordered_multimap container

Average case: constant
Worst case: linear in container size

auto it = m.find(k)
Searches the container for an element with a key equivalent to k and returns an iterator to it if found
otherwise it returns an iterator to unordered_map::end

int main ()
{
     unordered_map<char,int> mymap;
     unordered_map<char,int>::iterator it;

     mymap['a']=50;
     mymap['b']=100;
     mymap['c']=150;
     mymap['d']=200;

     it = mymap.find('b');
     if (it != mymap.end())
     mymap.erase (it);              // erase b
     
     cout << "a => " << mymap.find('a')->second << '\n';  // 50
     cout << "c => " << mymap.find('c')->second << '\n';  // 150 
     cout << "d => " << mymap.find('d')->second << '\n';  // 200

  return 0;
}
Average case: constant.
Worst case: linear in container size.

                                     equal_range
Returns the bounds of a range that includes all the elements in the container with a key that compares equal to k

int main()
{
      unordered_multimap<string,string> stringmap;
      stringmap myumm = {
      {"orange","FL"},
      {"strawberry","LA"},
      {"strawberry","OK"},
      {"pumpkin","NH"}      };

      cout << "Entries with strawberry:";
      auto range = myumm.equal_range("strawberry");
      
Complexity : ( Average case ==>> constant ) & ( Worst case: linear in container size )

********************unordered_multimap******************
unordered_multimaps store elements formed by a combination of a key value and a mapped value
unordered_multimap is a map that allows duplicated keys 
unordered_multimap has properties of map except (at,[]) because Random access is not supported 
