********************* Buckets *******************************
m.bucket_count() // Returns the number of buckets in the container // O(1)
m.max_bucket_count() // Returns the maximum number of buckets that container can have// O(1)
m.max_bucket_count()=st.max()=536870911
m.bucket_size(n) // Returns the number of elements in bucket n // O(bucket size)
m.bucket(n) // Returns the bucket number where the element with value k is located // O(1)
Assume that the number of buckets in any container is n , the first bucket = 0 , the second =1 ,...., the last bucket = n-1

st.rehash(n) // Sets the number of buckets in the container to n or more & n should be greater than bucket.count() to avoid drawbackets
Average case: linear in container size.
Worst case: quadratic in container size.


********************* Operations *******************************
int cnt = m.count(val);
Searches the container for elements with a key equivalent to k and returns the number of matches
Because all elements in a unordered_map container are unique, the function can only return 1 (if the element is found) or zero(otherwise)
but not at unordered_multimap container

Average case: linear in the number of elements counted
Worst case: linear in container size

auto it = m.find(val)
Searches the container for an element with a key equivalent to k and returns an iterator to it if found
otherwise it returns an iterator to unordered_map::end

int main ()
{
     unordered_map<char,int> mymap;
     unordered_map<char,int>::iterator it;

     mymap['a']=50;
     mymap['b']=100;
     mymap['c']=150;
     mymap['d']=200;

     it = mymap.find('b');
     if (it != mymap.end())
     mymap.erase (it);              // erase b
     
     cout << "a => " << mymap.find('a')->second << '\n';  // 50
     cout << "c => " << mymap.find('c')->second << '\n';  // 150 
     cout << "d => " << mymap.find('d')->second << '\n';  // 200

  return 0;
}
Average case: constant.
Worst case: linear in container size.
                                     equal_range
Returns the bounds of a range that includes all the elements in the container with a key that compares equal to k

int main()
{
      unordered_multimap<string,string> stringmap;
      stringmap myumm = {
      {"orange","FL"},
      {"strawberry","LA"},
      {"strawberry","OK"},
      {"pumpkin","NH"}      };

      cout << "Entries with strawberry:";
      auto range = myumm.equal_range("strawberry");
     for_each (range.first, range.second,[](stringmap::value_type& x){cout << " " << x.second;}
  );

Complexity : ( Average case ==>> constant ) & ( Worst case: linear in container size )
