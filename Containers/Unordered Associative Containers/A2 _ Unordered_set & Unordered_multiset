********************* Buckets *******************************
st.bucket_count() // Returns the number of buckets in the container // O(1)
st.max_bucket_count() // Returns the maximum number of buckets that container can have// O(1)
st.max_bucket_count()=st.max()=536870911
st.bucket_size(n) // Returns the number of elements in bucket n // O(bucket size)
st.bucket(n) // Returns the bucket number where the element with value k is located // O(1)
Assume that the number of buckets in any container is n , the first bucket = 0 , the second =1 ,...., the last bucket = n-1

    unordered_set<int>st={33,63,83,23,74,84,13,59};
    int c=st.bucket_count();
    for(int i=0;i<c;i++)
    {
        cout<<"bucket #"<<i<<" contains : ";
        for(auto it=st.begin(i);it!=st.end(i);it++)
            cout<<*it<<' ';
        cout<<endl;
    }
st.rehash(n) // Sets the number of buckets in the container to n or more & n should be greater than bucket.count() to avoid drawbackets
Average case: linear in container size.
Worst case: quadratic in container size.

Unordered_multisets are containers that store elements , and where unordered_multiple elements 
can have equivalent values and it has the some properties of unordered_set

********************* Operations  *************************
int cnt = st.count(val);
Searches the container for elements equivalent to val and returns the number of matches
Because all elements in a unordered_set container are unique, the function can only return 1 (if the element is found) or 0 (otherwise)
Complexity : ( Average case ==>> constant ) & ( Worst case: linear in container size )

auto it = st.find(val)
Searches the container for an element equivalent to val and returns an iterator to it if found
otherwise it returns an iterator to unordered_set::end
Complexity : ( Average case ==>> constant ) & ( Worst case: linear in container size )

                                     equal_range
Returns the bounds of a range that includes all the elements in the container that compare equal to k
but in unordered_set containers, where keys are unique, the range will include one element at most

    unordered_multiset<string> myums = {"cow","pig","pig","chicken","pig","chicken"};
    auto myrange = myums.equal_range("pig");

    while ( myrange.first != myrange.second ) 
    cout << " " << *myrange.first++;                // pig pig pig
  
    OR >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
    unordered_set<string> myums = {"cow","pig","pig","chicken","pig","chicken"};
    auto myrange = myums.equal_range("pig");

    while ( myrange.first != myrange.second ) 
    cout << " " << *myrange.first++;                // pig 
Complexity : ( Average case ==>> constant ) & ( Worst case: linear in container size )
