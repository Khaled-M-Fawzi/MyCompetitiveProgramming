unordered_Sets are containers that store unique elements 
#inlcude<unordered_set>
unordered_set<object_type>object_name;
********************* Iterators *****************************
st.begin()    || O(1) || Returns an iterator pointing to the first element 
st.end()      || O(1) || Returns an iterator pointing to the last element  
st.cbegin()   || O(1) || Returns a const_iterator pointing to the first element 
st.cend()     || O(1) || Returns a const_iterator pointing to the last element 
********************* Capacity ********************************
st.size()     || O(1) || Returns the number of elements 
st.max_size() || O(1) || Returns the maximum number of elements that the container can hold
st.empty()    || O(1) || Returns whether the container is empty 
********************* Modifiers *******************************
st.insert(val)   OR 
st.insert(iterator,val)  (faster) //iterator = st.begin()   OR 
st1.insert(st2 first iterator,st2 last iterator) 
Single element insertions:
Average case: constant.
Worst case: linear in container size.
Multiple elements insertion:
Average case: linear in the number of elements inserted.
Worst case: N*size: number of elements inserted times the container size 
May trigger a rehash (not included).

st.erase(iterator) O(log n) OR st.erase(val) O(log n) OR 
st.erase(first iterator , last iterator) 
Average case: Linear in the number of elements removed 
Worst case: Linear in the container size

st.emplace(val) || Average case: constant , Worst case: linear in container size
st.emplace_hint(iterator,val) || Average case: constant , Worst case: linear in container size (faster than st.emplace)
for emplcace and emplace_hint May trigger a rehash (not included).
 
st1.swap(st2)         || O(1) || Swap two container
st.clear()  || Linear in size || Removes all elements , leaving the vector with a size of 0

********************* Member functions *******************************
st1.operator=(st2) OR st1=st2|| Linear in size || Assigns new contents , replacing its current contents, and modifying its size   

********************* Buckets *******************************
st.bucket_count() // Returns the number of buckets in the container // O(1)
st.max_bucket_count() // Returns the maximum number of buckets that container can have// O(1)
st.max_bucket_count()=st.max()=536870911
st.bucket_size(n) // Returns the number of elements in bucket n // O(bucket size)
st.bucket(n) // Returns the bucket number where the element with value k is located // O(1)
Assume that the number of buckets in any container is n , the first bucket = 0 , the second =1 ,...., the last bucket = n-1

    unordered_set<int>st={33,63,83,23,74,84,13,59};
    int c=st.bucket_count();
    for(int i=0;i<c;i++)
    {
        cout<<"bucket #"<<i<<" contains : ";
        for(auto it=st.begin(i);it!=st.end(i);it++)
            cout<<*it<<' ';
        cout<<endl;
    }
st.rehash(n) // Sets the number of buckets in the container to n or more & n should be greater than bucket.count() to avoid drawbackets
Average case: linear in container size.
Worst case: quadratic in container size.

Unordered_multisets are containers that store elements , and where unordered_multiple elements 
can have equivalent values and it has the some properties of unordered_set
