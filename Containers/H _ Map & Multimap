Maps store elements formed by a combination of a key value and a mapped value, following a specific order
#include <map>
map<int,object_type>object_name;
********************* Iterators *****************************
m.begin()    || O(1) || Returns an iterator pointing to the first element 
m.end()      || O(1) || Returns an iterator pointing to the last element 
m.rbegin()   || O(1) || Returns a reverse iterator pointing to the last element 
m.rend()     || O(1) || Returns a reverse iterator pointing to the first element 
m.cbegin()   || O(1) || Returns a const_iterator pointing to the first element 
m.cend()     || O(1) || Returns a const_iterator pointing to the last element 
m.crbegin()  || O(1) || Returns a const_reverse_iterator pointing to the last element 
m.crend()    || O(1) || Returns a const_reverse_iterator pointing to the first element 
********************* Capacity ********************************
m.size()     || O(1) || Returns the number of elements 
m.max_size() || O(1) || Returns the maximum number of elements that the container can hold
m.empty()    || O(1) || Returns whether the container is empty 
********************* Element Access ************************** 
m.at(pos)    || O(log n) || Returns a reference to the element at position pos (O-Indexed)
operator[pos]|| O(log n) || Returns a reference to the element at position pos (O-Indexed)
********************* Modifiers *******************************
m.insert({key,val}) O(log n)   OR 
m.insert(iterator,{key,val}) O(log n) (faster) //iterator = m.begin()   OR 
m1.insert(m2 first iterator,m2 last iterator) Complexity : number of elements inserted * log n

m.erase(iterator) O(log n) OR m.erase(key) O(log n) OR 
m.erase(first iterator , last iterator) Complexity : number of elements erased * log n


m.emplace({key,val}) || Insert a new element O(log n)   (faster)
m.emplace_hint(iterator,{key,val}) || Insert a new element with a pointer hint O(log n) (faster than v.emplace)
 
m1.swap(m2)         || O(1) || Sawp two container
swap(m[0],m[2])     || O(1) || Sawp two vals
m.clear()  || Linear in size || Removes all elements , leaving the vector with a size of 0
********************* Member functions *******************************
m1.operator=(m2) OR m1=m2|| Linear in size || Assigns new contents , replacing its current contents, and modifying its size   
********************multimap******************
Multimaps store elements formed by a combination of a key value and a mapped value, following a specific order
multimap is a map that allows duplicated keys but not sorted
multimap has properties of map except (at,[]) because Random access is not supported 
