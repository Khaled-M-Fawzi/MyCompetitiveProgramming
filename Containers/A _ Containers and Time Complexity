Sequence Containers
1-array   2-vector   3-deque   4-list   5-forward list
Associative Containers
1-map    2-multimap    3-set    4-multiset
Unordered Associative Containers
1-unordered_map    2-unordered_multimap    3-unordered_set    4-unordered_multiset
for Associative container(map and unordered_map) supported random access (at,[])

static memory allocation ==>> fixed size ==>>  int a[10]
dynamic memory allocation ==>> size varies ==>>  stack , queue

When there is more than one way to solve a problem. We need to learn how to compare their performances to choose the best one
The exact time needed for a program to finish executing depends on lots of things like hardware, operating system, processors
However, we don't consider any of these factors while analyzing an algorithm. We will only consider the execution time of the algorithm 
with respect to the size of input fed to the program. This measurement is called "Time Complexity" or "Order of Growth"

An easier way to get a rough estimation of whether an algorithm will pass for a given problem size or not, is simply to substitute
with the problem's limits in the upper-bound function of your algorithm
For example, if your algorithm is O(N^2), and N (which is the array size for example) in this problem is up to 1000
Then you can substitute N with 1000 in the N^2 equation, which will give you 1000000
If the number you get from this substitution is <= 10^8, then "most probably" your solution will not exceed the time limit 
for most of the problems (which is about 2 seconds)

int i=5; O(1)
for(int i=0;i<n;i++)
   k+=a[i];                O(n)
   
for(int i=0;i<n;i++)
    for(int j=0;j<n;j++)
       k+=a[i][j];            O(n*n)

for(int i=0;i<n;i++)
    for(int j=0;j<n;j++)
        for(int k=0;k<n;k++)
           cnt+=a[j][k];          O(n*n*n)


for(int i=0;i<=sqrt(n);i++)
  k+=a[i];                           O(sqrt(n))
