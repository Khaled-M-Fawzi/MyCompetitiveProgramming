

Tree Data Structure
Search - Remove - Add ==>>{ O(log n) - Best Case } , { O(n) - Worst Case }

Tree types 
1) Binary Tree ( Binary Search Tree , AVL tree or Height Balanced Binary Tree , Red-black tree )
2) B Tree
3) Heaps
4) Trees
5) Multiway tree
6) Application Specific tree
7) Huffman Coding Tree


                A           Level : 0
             /  |  \ brunch or edge
            B   E   F       Level : 1
          /  \    / | \ brunch
         C    D  G  H  I    Level : 2
     
     (this tree has 8 brunch(edges) and 9 nodes)

root      -->> A
parent    -->> A , B , F
children  -->> B,E,F  C,D  G,H,I
leaves    -->> C,D  E  G,H,I
internal nodes (is parent and children at the same time)  -->> B , F
Siblings  -->> {B,E,F}  {C,D}   {G,H,I}
Ancestor  -->> C{A,B}  E{A}    I{A,F}
Depth(C) = 2 (path from root to C) , Depth(E) = 1 , Depth(A) = 0
Height(B) = 1 (path from B to the farthest leave node) , Height(A) = 2
Height of tree is path from root to the farthest leave node
Height of empty tree is -1
Height of tree that has only one node is zero
Edges = number of nodes - 1 
outdegree(A) = 3 (number of nodes branched from A) , outdegree(B) = 2 , outdegree(H) = 0
indegree(F) = 1 (number of nodes that F is branched from) , indegree(A) = 0
total degree(B) = outdegree(B) + indegree(B) = 2 + 1 = 3
Parenthetical notation = A(B(CD)EF(GHI))

            B   
          /  \     is subtree of above tree
         C    D

Binary Tree is a tree data structure in which each node has at most two children 
which are referred to as the left child and the right child
in programming
struct node
{
     Type item;
     node* left;
     node* right;
};
      
                            (left,item,right)
                           /                \
                          /                  \
                 (left,item,right)     (left,item,right)
                 /               \                     \
                /                 \                     \
        (left,item,right)    (left,item,right)    (left,item,right)
        
        
Full(strictly) Binary Tree
if every node has zero or two children

           O
         /   \
        O     O
      /   \
     O     O
         /   \
        O     O
        
Complete Binary Tree
1) all levels is completely filled except the last level
2) all Nodes as left as possible in the last level

           O
         /   \
        O     O
      /   \
     O     O
   
   
This below binary trees is not complete binary tree
           O            
         /   \
        O     O
      /   \     \
     O     O     O
     
           O            
         /   \
        O     O
            /   \
           O     O
           

Perfect Binary tree
1) every node has two children except leaves
2) all leaves are at the same level
            O            
         /     \
        O       O
      /   \   /   \
     O     O O     O



Balanced Binary Tree
1) the height of tree = O(log2(n))
2) | height(left subtree) - height(right subtree) | <= 1   //   {1,0,-1}

          3 - 2 = (1)--> Balance Factor
           3O2          
         /     \
       2O1     2O1
      /   \   /   \
     O     O O     O
    /         \
   O           O

A degenerate (or Pathological) tree
1) every parent node has only one child eigher left or right
2) such trees are performance-wise same as linked-list
         
         O
          \
           O
            \
             O
              \
               O
                \
                 O



         Max no. of nodes at level L = 2^L
         Max no. of nodes in binary tree = 2^(h+1) - 1 (where h is height of tree)   //  as perfect tree
         
            O           Max no. of nodes at level 0 = 1 = 2^0
         /     \
        O       O       Max no. of nodes at level 1 = 2 = 2^1
      /   \   /   \
     O     O O     O    Max no. of nodes at level 2 = 4 = 2^2
     
     
     
Breadth-first traversal
level-order  -->> + A B
Depth-first traversal
Pre-order traversal  : root left right (VLR) or (XLR) -->> + A B
In-order traversal   : left root right (LVR) or (LXR)-->> A + B
post-order traversal : left right root (LRV) or (LRX) -->> A B +

                    +
                   / \
                  A   B
                  
               ****************
               
Pre-order traversal   : A B C D E F
In-order traversal    : C B D A E F
post-order traversal  : C D B F E A
level-order traversal : A B E C D F
                   A
                 /   \
                B     E
              /  \     \
             C    D     F
             
             go to C _ Binary Tree Traversal.cpp

Binary Search Tree is a node-based binary tree data structure which has the following properties
1) The left subtree of a node contains only nodes with keys lesser than the node’s key
2) The right subtree of a node contains only nodes with keys greater than the node’s key
3) The left and right subtree each must also be a binary search tree
                              8
                            /   \
                           3     10
                         /   \     \
                        1     6     14
                            /   \
                           4     7
                          
***********  Find Successor  ************
1) node has right subtree 
we find mimimum node at right subtree
successor(3) = 4 , successor(8) = 10
2) node doesn't have a right subtree 
Travel up using the parent pointer until you see a node which is left child of it’s parent.The parent of such a node is the successor
successor(7) = 8 , successor(14) = NULL , successor(1) = 3 , successor(4) = 6
***********  Find Predecessor  ************
  
1) node has left subtree 
we find maximum node at left subtree
predecessor(3) = 1 , predecessor(8) = 7
2) node doesn't have a left subtree
Travel up using the parent pointer until you see a node which is right child of it’s parent.The parent of such a node is the predecessor
predecessor(4) = 3 , predecessor(14) = 10 , predecessor(1) = NULL
              go to D _ Binary Search Tree.cpp
