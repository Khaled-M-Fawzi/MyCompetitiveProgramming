/v/v/v/v/v/v/v/v/v/v/v/v/v/v/  Complexity classes  /v/v/v/v/v/v/v/v/v/v/v/v/v/v/v/v/v/v/
The following list contains common time complexities of algorithms
*********** O(1) **********
constant time
The running time of a constant-time algorithm does not depend on the input size
A typical constant-time algorithm is a direct formula that calculates the answer
Ex. i++ , n = n*10 , ans += a + b 

*********** O(logn) **********
logarithmic time 
 A logarithmic algorithm often halves the input size at each step. The running time of such an algorithm is logarithmic
 because log2 n equals the number of times n must be divided by 2 to get 1

*********** O(sqrt(n)) **********
square root time 
A square root algorithm is slower than O(logn) but faster than O(n)
A special property of square roots is that square(n) = n / square(n)

*********** O(n) **********
linear time 
algorithm goes through the input a constant number of times . This is often the best possible time complexity
because it is usually necessary to access each input element at least once before reporting the answer

*********** O(nlogn) **********
linear logarithmic time 
This time complexity often indicates that the algorithm sorts the input
because the time complexity of efficient sorting algorithms is O(nlogn)
Another possibility is that the algorithm uses a data structure where each operation takes O(logn) 

*********** O(n^2) **********
quadratic time 
A quadratic algorithm often contains two nested loops. It is possible to go through all pairs of the input elements in O(n^2)

*********** O(n^3) **********
cubic time 
 A cubic algorithm often contains three nested loops. It is possible to go through all triplets of the input elements in O(n^3)
 
*********** O(2^n) **********
exponential time
This time complexity often indicates that the algorithm iterates through all subsets of the input elements. 
For example, the subsets of {1,2,3} are ; Î¦ , {1}, {2}, {3}, {1,2}, {1,3}, {2,3} and {1,2,3}

 *********** O(n!)**********
 factorial time	
 This time complexity often indicates that the algorithm iterates through all permutations of the input elements
 For example, the permutations of {1,2,3} are (1,2,3), (1,3,2), (2,1,3), (2,3,1), (3,1,2) and (3,2,1)

////////////////////////////////////////////////////////////
An algorithm is polynomial if its time complexity is at most O(n^k) k is a constant
Polynomial time :: n , log n , sqrt(n) , n^2  , n^3
Exponential time	       :: 2^Poly(n)    ==>> 2^n , 2^(n^2) 
Double exponential time	 :: 2^2^poly(n)  ==>> 2^2^n

2^(log n) ===>> Polynomial time
