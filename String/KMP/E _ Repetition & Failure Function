concatenate(abcd,3)=abcdabcdabcd
Given string concatenated , find minimum N
Ex. abcabcabc ==>> 3
Ex. abababab  ==>> 2
   it also can be 4(ab) but 2(abab) is smaller
EX. abc  ==>> 1
a b c d a b c d a b c d
0 0 0 0 1 2 3 4 5 6 7 8 (Failure Function)
//////////////////////////////////////////////////
As we match longest proper prefix NOT longest prefix 
That is if string is 10 times concatenated , the first 9 blocks = the last 9 blocks
here abcdabcd = abcdabcd ( 8 letters)
so we can get the block easily len-f[len-1]=12-8=4
if(len%(len-f[len-1])==0)
then len/(len-f[len-1]) is solution 
else there no solution
//////////////////////////////////////////////////
why all blocks are equal ?
let string s=concatenate(abcd,5) = abcdabcdabcdabcdabcd
let's divide string for 5 blocks ABCDE
//////////////////////////////////////////////////
F[len-1]=16 , which means first 16 = last 16
or first 4 blocks = last 4 blocks
ABCD = BCDE Then A = B , B = C , C = D , D = E
a b c d g h k m a b c d
0 0 0 0 0 0 0 0 1 2 3 4
len-F[len-1] = 8   12 % 8 != 0
what does this mean ? first 4 = last 4 , but in between is not like them
//////////////////////////////////////////////////
Another Way , using KMP itself
 let string input P = abcdabcdabcd
 let S = P + P = abcdabcdabcdabcdabcdabcd
 Now when we try to find P in S , it shoud match in 0 , k , 2k and so on
 So 2nd match is enough for answer
 abcdabcdabcdabcdabcdabcd ==>> 2nd match
     abcdabcdabcd
 and here i = 4
 answer = len / i
